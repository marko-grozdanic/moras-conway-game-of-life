class GameOfLife 
{
	field int numRows, numColumns, boardDimension, stepDelay;
	field Array Matrix, Buffer;
	
	constructor GameOfLife new() //Expects x and y as pixel resolution values(height, width)
	{
		let boardDimension = 2048;
		let stepDelay = 20; //Delay between displaying steps(in ms)
		let Matrix = Array.new(boardDimension);
		let Buffer = Array.new(boardDimension);
		do initialiseMatrix();
		do initialiseBuffer();
		return this;
	}
	
	method void dispose()
	{
		do Matrix.dispose();
		return;
	}
	
	method void start() 
	{			
		//Print game instructions
		// do printInstructions();
		//Initialise the Matrix based on user's scenario input
		do initialiseBoard(1);
		
		//Draw step zero
		do drawStep();
		
		// Calculate and draw next step
		while(true)
		{
			do calculateStep(); //Calculates a new Matrix
			do Sys.wait(500);
			do Screen.clearScreen();
			do drawStep(); //Prints the Matrix
			do Sys.wait(stepDelay); //Wait until next step 
		 }
		
		//End Simulation
		// do endGame();
		return;
	}
	
	method void initialiseBoard(int scenario)
	{
		if(scenario = 0) //Generate random cell setup
		{
			return;
		}
		if(scenario = 1) //Draw a blinker
		{	
			let Matrix[1056] = 1; //Center square
			let Matrix[1055] = 1;
			let Matrix[1057] = 1;
			
			// let Matrix[1056] = 1; //Center square
			// let Matrix[991] = 1;
			// let Matrix[1121] = 1;
			// let Matrix[1120] = 1;
			// let Matrix[1119] = 1;
			return;
		}
		if(scenario = 2) //Draw a toad
		{
			return;
		}
		if(scenario = 3) //Draw a beacon
		{
			return;
		}
		if(scenario = 4) //Draw a pulsar
		{
			return;
		}
		if(scenario = 5) //Draw a penta-decathlon
		{
			return;
		}
		if(scenario = 6) //Draw a glider
		{
			return;
		}
		if(scenario = 7) //Draw a heavy weight spaceship
		{
			return;
		}
		return;
	}
	
	//method void drawSquare(int xTop, int yTop)
	method void drawSquare(int cellNumber)
	{	
			var int xTop, yTop;
			var int k, l;
			
			let k = cellNumber / 64; //Find out which row of the board is the cell in [0, 31]
			// do Output.printInt(k);
			// do Output.println();
			let l = modulo(cellNumber, 64); //Find out which column of the row is the cell in [0, 63]
			// do Output.printInt(l);
			// do Output.println();
			
			let xTop = l * 8;
			// do Output.printInt(xTop);
			// do Output.println();
			let yTop = k * 8;
			// do Output.printInt(yTop);
			// do Output.println();

			do Screen.drawRectangle(xTop, yTop, xTop + 7, yTop + 7); 
			
			return;
			// if ((x1 < 0) | (x1 > 511) | (y1 < 0) | (y1 > 255) |
			// (x2 < 0) | (x2 > 511) | (y2 < 0) | (y2 > 255) |
			// (x1 > x2) | (y1 > y2)) {
			// do Sys.error(9); // Screen.drawRectangle: Illegal rectangle coordinates    
	}
	
	method void calculateStep() //Calculates the next Matrix state
	{	
		var int i, aliveNeighbouringCells;
		//let i = 0;
		let i = 100;
		let aliveNeighbouringCells = 0;
		let Buffer = Matrix; //Make a copy of the previous state
		
		// while(i < boardDimension)
		while(i < 1950)
		{	
			if(Buffer[i-64] = 1) //North 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+64] = 1) //South 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+1] = 1) //East 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i-1] = 1) //West 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i-63] = 1) //Northeast 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+65] = 1) //Southeast 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+63] = 1) //Southwest 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i-65] = 1) //Northwest 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			
			if(Buffer[i] = 1) //The cell was previously alive, it will stay alive only if it has two or three alive neighbours
			{
				let Matrix[i] = 0; //Dead by default
				if(aliveNeighbouringCells = 2)
				{
					let Matrix[i] = 1;
				}
				if(aliveNeighbouringCells = 3)
				{
					let Matrix[i] = 1;
				}
			}
			else //The cell was previously dead, it will only come alive if it has exactly three neighbours
			{
				if(aliveNeighbouringCells = 3)
				{
					let Matrix[i] = 1;
				}
				else
				{
					let Matrix[i] = 0;
				}
				
			}
			let i = i + 1;
		}
		return;
	}
	
	method void drawStep() //Draws the current Matrix state
	{	
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			if(Matrix[i] = 1)
			{
				do drawSquare(i);
			}
			
			let i = i + 1;
		}
		
		return;
	}
	
	method void drawBoard() //Test function that sequentially draws every square in the board 
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			do drawSquare(i);
			do Sys.wait(5);
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void initialiseMatrix() //Sets all matrix elements to integer 0;
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			let Matrix[i] = 0;
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void initialiseBuffer() //Sets all matrix elements to integer 0;
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			let Matrix[i] = 0;
						
			let i = i + 1;
		}
		
		return;
	}
	
	method int modulo(int a, int b)
	{
		var int result;
		let result = a - (b * (a/b));
		return result;
	}
	
}	
