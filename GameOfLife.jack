class GameOfLife 
{
	field int numRows, numColumns, boardDimension, stepDelay;
	field bool paused;
	field Array Matrix, Buffer;
	
	constructor GameOfLife new()
	{
		let boardDimension = 2048;
		let stepDelay = 1000; //Delay between displaying steps(in ms)
		let Matrix = Array.new(boardDimension);
		let Buffer = Array.new(boardDimension);
		let paused = false; //The game should be unpaused by default
		do initialiseMatrix(); //Set matrix values to 0
		do initialiseBuffer(); //Set buffer values to 0
		return this;
	}
	
	method void dispose()
	{
		do Matrix.dispose();
		do Buffer.dispose();
		return;
	}
	
	method void start(int seed) 
	{	
		var char c;
		do LCGRandom.setSeed(seed); //Set the seed for random generation
		
		//Print game instructions and wait for scenario input
		do Graphics.printInstructions();
		do Sys.wait(200);
		let c = Keyboard.readChar();
		do Screen.clearScreen();
		
		//Initialise the Matrix based on user's scenario input
		do addCellsToBoard(c);
		
		//Draw step zero
		do drawStep();
		
		// Calculate and draw next step
		while(true)
		{
			if(Keyboard.keyPressed() = 32) //Space pressed, unpause
				{
					let paused = false;
					do Sys.wait(300);
				}
			while(~(paused)) //Game isn't paused
			{
				if(~(Keyboard.keyPressed() = 0)) //A key has been pressed
				{
					let c = Keyboard.keyPressed();
					do handleInput(c);
				}
				do Sys.wait(stepDelay); //Wait until next step 
				do calculateStep(); //Calculates a new Matrix
				do Screen.clearScreen();
				do drawStep(); //Prints the Matrix
			}			
		 }
		
		//End Simulation
		// do endGame();
		return;
	}
	
	//method void drawSquare(int xTop, int yTop)
	method void drawSquare(int cellNumber)
	{	
			var int xTop, yTop;
			var int k, l;
			
			let k = cellNumber / 64; //Find out which row of the board is the cell in [0, 31]
			let l = ExtraMath.modulo(cellNumber, 64); //Find out which column of the row is the cell in [0, 63]
			
			let xTop = l * 8;
			let yTop = k * 8;

			do Screen.drawRectangle(xTop, yTop, xTop + 7, yTop + 7); 
			
			return;
	}
	
	method void calculateStep() //Calculates the next Matrix state
	{	
		var int i, aliveNeighbouringCells;
		let i = 0;
		let aliveNeighbouringCells = 0;
		while(i < 2048)
		{
			let Buffer[i] = Matrix[i];
			let i = i+1;
		}
		let i = 0;
		while(i < 2048) //For every cell
		{	
			if((i-64) > -1) //North 
			{	
				if(Buffer[i-64] = 1)
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}				
			}
			if((i+64) < 2048) //South 
			{
				if(Buffer[i+64] = 1) 
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}
			if((i+1) < 2048) //East 
			{
				if(Buffer[i+1] = 1)
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}
			if((i-1) > -1) //West 
			{
				if(Buffer[i-1] = 1)
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}
			if((i-63) > -1) //Northeast 
			{
				if(Buffer[i-63] = 1)
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}
			if((i+65) < 2048) //Southeast 
			{
				if(Buffer[i+65] = 1)
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}
			if((i+63) < 2048) //Southwest 
			{
				if(Buffer[i+63] = 1)
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}			
			if((i-65) > -1) //Northwest 
			{
				if(Buffer[i-65] = 1) 
				{
					let aliveNeighbouringCells = aliveNeighbouringCells + 1;
				}
			}
			
			if(Buffer[i] = 1) //The cell was previously alive, it will stay alive only if it has two or three alive neighbours
			{
				let Matrix[i] = 0; //Dead by default
				if(aliveNeighbouringCells = 2)
				{
					let Matrix[i] = 1;
				}
				if(aliveNeighbouringCells = 3)
				{
					let Matrix[i] = 1;
				}
			}
			else //The cell was previously dead, it will only come alive if it has exactly three neighbours
			{
				// let Matrix[i] = 0; //It already is 0 in the matrix if it is 0 in the buffer
				if(aliveNeighbouringCells = 3)
				{
					let Matrix[i] = 1;
				}
				
			}
			let i = i + 1;
			let aliveNeighbouringCells = 0;
		}
		return;
	}
	
	method void handleInput(char key)
	{
		if(key = 130) //Left arrow
		{
			if(stepDelay > 199) //Don't go under 100ms delay
			{
				let stepDelay = stepDelay - 100;
			}			
			return;
		}
		if(key = 132) //Right arrow
		{
			let stepDelay = stepDelay + 100;
			return;
		}
		if(key = 32) //Space pauses or unpauses the game
		{
			let paused = true;
		}
		do addCellsToBoard(key);
		return;
	}
	
	method void drawStep() //Draws the current Matrix state
	{	
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			if(Matrix[i] = 1)
			{
				do drawSquare(i);
			}
			
			let i = i + 1;
		}
		
		return;
	}
		
	method void initialiseMatrix() //Sets all matrix elements to integer 0;
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			let Matrix[i] = 0;
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void initialiseBuffer() //Sets all matrix elements to integer 0;
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			let Matrix[i] = 0;
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void addCellsToBoard(int scenario)
	{
		var int i, j;
		if(scenario = 48) //Generate random cell setup
		{
			let i = 0;
			while(i < 2048)
			{
				let j = LCGRandom.randRange(0, 6);
				if(j = 1)
				{
					let Matrix[i] = 1;
				}
				let i = i + 1;
			}
			return;
		}
		if(scenario = 49) //Draw a blinker
		{	
			let Matrix[1056] = 1; //Center square
			let Matrix[1055] = 1;
			let Matrix[1057] = 1;
			return;
		}
		if(scenario = 50) //Draw a toad
		{
			let Matrix[1056] = 1; //Center square
			let Matrix[1057] = 1;
			let Matrix[1058] = 1;
			let Matrix[1121] = 1;
			let Matrix[1120] = 1;
			let Matrix[1119] = 1;
			return;
		}
		if(scenario = 51) //Draw a beacon
		{
			let Matrix[1053] = 1; 
			let Matrix[1054] = 1;
			let Matrix[1117] = 1;
			let Matrix[1118] = 1;
			
			let Matrix[1183] = 1;
			let Matrix[1184] = 1;
			let Matrix[1247] = 1;
			let Matrix[1248] = 1;
			return;
		}
		if(scenario = 52) //Draw a pulsar
		{
			let Matrix[991] = 1; 
			let Matrix[992] = 1; 
			let Matrix[993] = 1; 
			let Matrix[931] = 1; 
			let Matrix[867] = 1; 
			let Matrix[803] = 1; 
			let Matrix[926] = 1; 
			let Matrix[862] = 1; 
			let Matrix[798] = 1; 
			let Matrix[671] = 1; 
			let Matrix[672] = 1; 
			let Matrix[673] = 1; 
			
			let Matrix[985] = 1; 
			let Matrix[986] = 1; 
			let Matrix[987] = 1; 
			let Matrix[924] = 1; 
			let Matrix[860] = 1; 
			let Matrix[796] = 1; 
			let Matrix[667] = 1; 
			let Matrix[666] = 1; 
			let Matrix[665] = 1; 
			let Matrix[919] = 1; 
			let Matrix[855] = 1; 
			let Matrix[791] = 1; 
			
			let Matrix[1119] = 1; 
			let Matrix[1120] = 1; 
			let Matrix[1121] = 1; 
			let Matrix[1439] = 1; 
			let Matrix[1440] = 1; 
			let Matrix[1441] = 1; 
			let Matrix[1310] = 1; 
			let Matrix[1246] = 1; 
			let Matrix[1182] = 1; 
			let Matrix[1315] = 1; 
			let Matrix[1251] = 1; 
			let Matrix[1187] = 1; 
			
			let Matrix[1113] = 1; 
			let Matrix[1114] = 1; 
			let Matrix[1115] = 1; 
			let Matrix[1180] = 1; 
			let Matrix[1244] = 1; 
			let Matrix[1308] = 1; 
			let Matrix[1435] = 1; 
			let Matrix[1434] = 1; 
			let Matrix[1433] = 1; 
			let Matrix[1303] = 1; 
			let Matrix[1239] = 1; 
			let Matrix[1175] = 1; 
			
			return;
		}
		if(scenario = 53) //Draw a penta-decathlon
		{
			let Matrix[1048] = 1; 
			let Matrix[1049] = 1; 
			let Matrix[986] = 1; 
			let Matrix[1114] = 1; 
			let Matrix[1051] = 1; 
			let Matrix[1052] = 1; 
			
			let Matrix[1053] = 1;
			let Matrix[1054] = 1;
			let Matrix[1119] = 1;
			let Matrix[991] = 1;
			let Matrix[1056] = 1;
			let Matrix[1057] = 1;
			return;
		}
		if(scenario = 54) //Draw a glider
		{
			let Matrix[992] = 1;
			let Matrix[1057] = 1;
			let Matrix[1121] = 1;
			let Matrix[1120] = 1;
			let Matrix[1119] = 1;
			return;
		}
		if(scenario = 55) //Draw a heavy weight spaceship
		{
			let Matrix[998] = 1; 
			let Matrix[870] = 1; 
			let Matrix[803] = 1; 
			let Matrix[804] = 1; 
			let Matrix[865] = 1; 
			let Matrix[928] = 1; 
			let Matrix[992] = 1; 
			let Matrix[1056] = 1; 
			let Matrix[1057] = 1; 
			let Matrix[1058] = 1; 
			let Matrix[1059] = 1; 
			let Matrix[1060] = 1; 
			let Matrix[1061] = 1; 
			return;
		}
		return;
	}
	
	method void drawBoard() //Test function that sequentially draws every square in the board 
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			do drawSquare(i);
			do Sys.wait(5);
						
			let i = i + 1;
		}
		
		return;
	}
	
}	
