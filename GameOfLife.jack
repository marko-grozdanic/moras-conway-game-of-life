class GameOfLife 
{
	field int numRows, numColumns, boardDimension, stepDelay;
	field Array Matrix, Buffer;
	
	constructor GameOfLife new() //Expects x and y as pixel resolution values(height, width)
	{
		let boardDimension = 2048;
		let stepDelay = 500; //Delay between displaying steps(in ms)
		let Matrix = Array.new(boardDimension);
		let Buffer = Array.new(boardDimension);
		do initialiseMatrix();
		do initialiseBuffer();
		return this;
	}
	
	method void dispose()
	{
		do Matrix.dispose();
		return;
	}
	
	method void start() 
	{			
		//Print game instructions
		// do printInstructions();
		//Initialise the Matrix based on user's scenario input
		do initialiseBoard(1);
		
		//Draw step zero
		do drawStep();
		
		// Calculate and draw next step
		while(true)
		{
			do Sys.wait(stepDelay); //Wait until next step 
			do calculateStep(); //Calculates a new Matrix
			do Screen.clearScreen();
			do drawStep(); //Prints the Matrix
		 }
		
		//End Simulation
		// do endGame();
		return;
	}
	
	//method void drawSquare(int xTop, int yTop)
	method void drawSquare(int cellNumber)
	{	
			var int xTop, yTop;
			var int k, l;
			
			let k = cellNumber / 64; //Find out which row of the board is the cell in [0, 31]
			// do Output.printInt(k);
			// do Output.println();
			let l = ExtraMath.modulo(cellNumber, 64); //Find out which column of the row is the cell in [0, 63]
			// do Output.printInt(l);
			// do Output.println();
			
			let xTop = l * 8;
			// do Output.printInt(xTop);
			// do Output.println();
			let yTop = k * 8;
			// do Output.printInt(yTop);
			// do Output.println();

			do Screen.drawRectangle(xTop, yTop, xTop + 7, yTop + 7); 
			
			return;
			// if ((x1 < 0) | (x1 > 511) | (y1 < 0) | (y1 > 255) |
			// (x2 < 0) | (x2 > 511) | (y2 < 0) | (y2 > 255) |
			// (x1 > x2) | (y1 > y2)) {
			// do Sys.error(9); // Screen.drawRectangle: Illegal rectangle coordinates    
	}
	
	method void calculateStep() //Calculates the next Matrix state
	{	
		var int i, aliveNeighbouringCells;
		let i = 65;
		let aliveNeighbouringCells = 0;
		let Buffer = Matrix; //Make a copy of the previous state
		
		// while(i < boardDimension)
		while(i < 1983)
		{	
			if(Buffer[i-64] = 1) //North 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+64] = 1) //South 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+1] = 1) //East 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i-1] = 1) //West 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i-63] = 1) //Northeast 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+65] = 1) //Southeast 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i+63] = 1) //Southwest 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			if(Buffer[i-65] = 1) //Northwest 
			{
				let aliveNeighbouringCells = aliveNeighbouringCells + 1;
			}
			
			if(Buffer[i] = 1) //The cell was previously alive, it will stay alive only if it has two or three alive neighbours
			{
				let Matrix[i] = 0; //Dead by default
				if(aliveNeighbouringCells = 2)
				{
					let Matrix[i] = 1;
				}
				if(aliveNeighbouringCells = 3)
				{
					let Matrix[i] = 1;
				}
			}
			else //The cell was previously dead, it will only come alive if it has exactly three neighbours
			{
				// let Matrix[i] = 0; //It already is 0 in the matrix if it is 0 in the buffer
				if(aliveNeighbouringCells = 3)
				{
					let Matrix[i] = 1;
				}
				
			}
			let i = i + 1;
			let aliveNeighbouringCells = 0;
		}
		return;
	}
	
	method void drawStep() //Draws the current Matrix state
	{	
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			if(Matrix[i] = 1)
			{
				do drawSquare(i);
			}
			
			let i = i + 1;
		}
		
		return;
	}
	
	method void drawBoard() //Test function that sequentially draws every square in the board 
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			do drawSquare(i);
			do Sys.wait(5);
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void initialiseMatrix() //Sets all matrix elements to integer 0;
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			let Matrix[i] = 0;
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void initialiseBuffer() //Sets all matrix elements to integer 0;
	{
		var int i;
		let i = 0;
		while(i < boardDimension)
		{
			let Matrix[i] = 0;
						
			let i = i + 1;
		}
		
		return;
	}
	
	method void initialiseBoard(int scenario)
	{
		if(scenario = 0) //Generate random cell setup
		{
			return;
		}
		if(scenario = 1) //Draw a blinker
		{	
			let Matrix[1056] = 1; //Center square
			let Matrix[1055] = 1;
			let Matrix[1057] = 1;
			return;
		}
		if(scenario = 2) //Draw a toad
		{
			let Matrix[1056] = 1; //Center square
			let Matrix[1057] = 1;
			let Matrix[1058] = 1;
			let Matrix[1121] = 1;
			let Matrix[1120] = 1;
			let Matrix[1119] = 1;
			return;
		}
		if(scenario = 3) //Draw a beacon
		{
			let Matrix[1053] = 1; 
			let Matrix[1054] = 1;
			let Matrix[1117] = 1;
			let Matrix[1118] = 1;
			
			let Matrix[1183] = 1;
			let Matrix[1184] = 1;
			let Matrix[1247] = 1;
			let Matrix[1248] = 1;
			return;
		}
		if(scenario = 4) //Draw a pulsar
		{
			let Matrix[991] = 1; 
			let Matrix[992] = 1; 
			let Matrix[993] = 1; 
			let Matrix[931] = 1; 
			let Matrix[867] = 1; 
			let Matrix[803] = 1; 
			let Matrix[926] = 1; 
			let Matrix[862] = 1; 
			let Matrix[798] = 1; 
			let Matrix[671] = 1; 
			let Matrix[672] = 1; 
			let Matrix[673] = 1; 
			
			let Matrix[985] = 1; 
			let Matrix[986] = 1; 
			let Matrix[987] = 1; 
			let Matrix[924] = 1; 
			let Matrix[860] = 1; 
			let Matrix[796] = 1; 
			let Matrix[667] = 1; 
			let Matrix[666] = 1; 
			let Matrix[665] = 1; 
			let Matrix[919] = 1; 
			let Matrix[855] = 1; 
			let Matrix[791] = 1; 
			
			let Matrix[1119] = 1; 
			let Matrix[1120] = 1; 
			let Matrix[1121] = 1; 
			let Matrix[1439] = 1; 
			let Matrix[1440] = 1; 
			let Matrix[1441] = 1; 
			let Matrix[1310] = 1; 
			let Matrix[1246] = 1; 
			let Matrix[1182] = 1; 
			let Matrix[1315] = 1; 
			let Matrix[1251] = 1; 
			let Matrix[1187] = 1; 
			
			let Matrix[1113] = 1; 
			let Matrix[1114] = 1; 
			let Matrix[1115] = 1; 
			let Matrix[1180] = 1; 
			let Matrix[1244] = 1; 
			let Matrix[1308] = 1; 
			let Matrix[1435] = 1; 
			let Matrix[1434] = 1; 
			let Matrix[1433] = 1; 
			let Matrix[1303] = 1; 
			let Matrix[1239] = 1; 
			let Matrix[1175] = 1; 
			
			return;
		}
		if(scenario = 5) //Draw a penta-decathlon
		{
			let Matrix[1048] = 1; 
			let Matrix[1049] = 1; 
			let Matrix[986] = 1; 
			let Matrix[1114] = 1; 
			let Matrix[1051] = 1; 
			let Matrix[1052] = 1; 
			
			let Matrix[1053] = 1;
			let Matrix[1054] = 1;
			let Matrix[1119] = 1;
			let Matrix[991] = 1;
			let Matrix[1056] = 1;
			let Matrix[1057] = 1;
			return;
		}
		if(scenario = 6) //Draw a glider
		{
			let Matrix[992] = 1;
			let Matrix[1057] = 1;
			let Matrix[1121] = 1;
			let Matrix[1120] = 1;
			let Matrix[1119] = 1;
			return;
		}
		if(scenario = 7) //Draw a heavy weight spaceship
		{
			let Matrix[998] = 1; 
			let Matrix[870] = 1; 
			let Matrix[803] = 1; 
			let Matrix[804] = 1; 
			let Matrix[865] = 1; 
			let Matrix[928] = 1; 
			let Matrix[992] = 1; 
			let Matrix[1056] = 1; 
			let Matrix[1057] = 1; 
			let Matrix[1058] = 1; 
			let Matrix[1059] = 1; 
			let Matrix[1060] = 1; 
			let Matrix[1061] = 1; 
			return;
		}
		return;
	}
	
}	
